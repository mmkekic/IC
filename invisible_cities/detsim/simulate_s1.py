"""
---------------------------
    detsim s1 simulation
---------------------------

This module contains the functions that implement s1 simulation in detsim.
s1 is simulated following the steps:

- compute the number of scintillation photons emitted by track-hits.
- use the s1 lighttable to compute the number of pes at each PMT produced by each hit.
-----------
Important: Note that not delay is assumed between emission of light from the track and the arrival time
at the PMTs. In detsim the s1 photons arrive instantaneously to the PMTs.
This can cause some mismatch between detsim and fullsim s1 variables in large detectors.
----------
- for each pes arriving at the PMT, the s1-times (ie, the times in which they generate signal)
are computed using the s1-distribution plus the hit emission time.
- finally, the s1-times are bufferized in a waveform.
"""

import os
import numpy as np

from typing import Callable

from scipy.optimize import brentq

from .. core import system_of_units as units


def compute_scintillation_photons(energy : np.ndarray,
                                  ws     : float) -> np.ndarray:
    """
    Computes the number of scintillation photons produced
    in each energy deposition hit
    Parameters:
        :energy: np.ndarray
            vector with the energy values of each hit
        :ws: float
            inverse scintillation yield
    Returns:
        np.ndarray
        The number of photons at each hit they are poisson
        distributed with mean energy/ws
    """
    return np.random.poisson(energy / ws)


def compute_s1_pes_at_pmts(xs      : np.ndarray,
                           ys      : np.ndarray,
                           zs      : np.ndarray,
                           photons : np.ndarray,
                           lt      : Callable  )->np.ndarray:
    """
    Compute the pes generated in each PMT from S1 photons
    Parameters:
        :LT: function
            The Light Table in functional form
        :photons: np.ndarray
            The photons generated at each hit
        :xs, ys, zs: np.ndarray
            hit position
    Returns:
        :pes: np.ndarray
            photoelectrons at each PMT produced by all hits.
            shape is (number_of_sensors, number_of_hits)
    """
    pes = photons[:, np.newaxis] * lt(xs, ys, zs)
    pes = np.random.poisson(pes)
    return pes.T


def generate_s1_time(size : int=1)->np.ndarray:
    """
    Generate random numbers following two exponential distributions
    with different probabilities, such that (values in nano-seconds):
    -with prob 0.1: exp(-x/4.5)
    -with prob 0.9: exp(-x/100)
    """
    tau1 = 4.5 * units.ns
    tau2 = 100 * units.ns
    p1 = 0.1

    sel = np.random.uniform(0, 1, size=size)
    size_1 = np.sum(sel<=p1)
    size_2 = size - size_1
    r1 = np.random.exponential(tau1, size_1)
    r2 = np.random.exponential(tau2, size_2)
    r  = np.concatenate([r1, r2])
    np.random.shuffle(r)
    return r


def generate_s1_times_from_pes(s1_pes_at_pmts : np.ndarray,
                               hit_times      : np.ndarray)->list:
    """
    Given the s1_pes_at_pmts, this function returns the times at which the pes
    are distributed (see generate_S1_time function).
    It returns a list whose elements are the times at which the photoelectrons in that PMT
    are generated.
    Parameters:
        :s1_pes_at_pmts: np.ndarray
            the pes at each PMT generated by each hit
        :hit_times: np.ndarray
            emission time of each hit
    Returns:
        :s1_times: list[np.ndarray,..]
            Each element are the S1 times for a PMT. If certain sensor
            do not see any pes, the array is empty.
    """
    s1_times = []
    for pes_at_pmt in s1_pes_at_pmts:
        repeated_times = np.repeat(hit_times, pes_at_pmt)
        times = generate_s1_time(np.sum(pes_at_pmt))
        s1_times.append(times + repeated_times)
    return s1_times
